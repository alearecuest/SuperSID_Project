import React, { useState, useEffect } from 'react';
import '../styles/pages.css';

interface DataVisualizationProps {
  stationId: number;
}

interface VLFSignal {
  timestamp: string;
  frequency: number;
  amplitude: number;
  phase: number;
  snr: number;
  quality: number;
}

interface FrequencyBin {
  frequency: number;
  amplitude: number;
  count: number;
}

const DataVisualization: React.FC<DataVisualizationProps> = ({ stationId }) => {
  const [visualizationType, setVisualizationType] = useState<'spectrogram' | 'timeseries' | 'frequency'>('timeseries');
  const [timeRange, setTimeRange] = useState<'1h' | '6h' | '24h' | '7d'>('24h');
  const [isLoading, setIsLoading] = useState(true);
  const [signals, setSignals] = useState<VLFSignal[]>([]);
  const [frequencyBins, setFrequencyBins] = useState<FrequencyBin[]>([]);
  const [error, setError] = useState('');

  useEffect(() => {
    loadVisualizationData();
  }, [stationId, timeRange]);

  const getTimeRangeMs = (): number => {
    const ranges = {
      '1h': 3600000,
      '6h': 21600000,
      '24h': 86400000,
      '7d': 604800000,
    };
    return ranges[timeRange];
  };

  const loadVisualizationData = async () => {
    try {
      setIsLoading(true);
      setError('');

      const endTime = Date.now();
      const startTime = endTime - getTimeRangeMs();

      const response = await fetch(
        `http://localhost:3001/api/vlf-monitor/historical/${stationId}?startTime=${startTime}&endTime=${endTime}`
      );

      if (!response.ok) {
        throw new Error('Failed to fetch data');
      }

      const result = await response.json();

      if (result.success && result.data && result.data.length > 0) {
        const data: VLFSignal[] = result.data.map((item: any) => ({
          timestamp: item.timestamp,
          frequency: item.frequency,
          amplitude: item.amplitude,
          phase: item.phase,
          snr: item.snr,
          quality: item.quality,
        }));

        setSignals(data);
        processFrequencyBins(data);
      } else {
        setError('No data available for the selected time range');
        setSignals([]);
        setFrequencyBins([]);
      }
    } catch (err: any) {
      console.error('Failed to load visualization data:', err);
      setError(err.message || 'Failed to load data');
      setSignals([]);
      setFrequencyBins([]);
    } finally {
      setIsLoading(false);
    }
  };

  const processFrequencyBins = (data: VLFSignal[]) => {
    if (data.length === 0) {
      setFrequencyBins([]);
      return;
    }

    const binSize = 1000;
    const bins: { [key: number]: { sum: number; count: number } } = {};

    data.forEach(signal => {
      const binKey = Math.floor(signal.frequency / binSize) * binSize;
      if (!bins[binKey]) {
        bins[binKey] = { sum: 0, count: 0 };
      }
      bins[binKey].sum += signal.amplitude;
      bins[binKey].count += 1;
    });

    const binArray: FrequencyBin[] = Object.entries(bins)
      .map(([freq, data]) => ({
        frequency: parseInt(freq),
        amplitude: data.sum / data.count,
        count: data.count,
      }))
      .sort((a, b) => a.frequency - b.frequency);

    setFrequencyBins(binArray);
  };

  const renderTimeSeries = () => {
    if (signals.length === 0) {
      return (
        <div className="empty-state">
          <p>No data available for the selected time range</p>
          <small>Start the VLF Monitor to collect data</small>
        </div>
      );
    }

    const width = 800;
    const height = 300;
    const padding = { top: 20, right: 20, bottom: 40, left: 60 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;

    const timestamps = signals.map(s => new Date(s.timestamp).getTime());
    const minTime = Math.min(...timestamps);
    const maxTime = Math.max(...timestamps);
    const amplitudes = signals.map(s => s.amplitude);
    const minAmp = Math.min(...amplitudes);
    const maxAmp = Math.max(...amplitudes);
    const ampRange = maxAmp - minAmp || 1;

    const points = signals.map((signal, i) => {
      const x = padding.left + ((timestamps[i] - minTime) / (maxTime - minTime)) * chartWidth;
      const y = padding.top + chartHeight - ((signal.amplitude - minAmp) / ampRange) * chartHeight;
      return `${x},${y}`;
    }).join(' ');

    return (
      <div className="visualization-container">
        <svg viewBox={`0 0 ${width} ${height}`} className="chart-svg">
          <defs>
            <linearGradient id="amplitudeGradient" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" style={{ stopColor: '#0ea5e9', stopOpacity: 0.3 }} />
              <stop offset="100%" style={{ stopColor: '#0ea5e9', stopOpacity: 0 }} />
            </linearGradient>
          </defs>

          {Array.from({ length: 5 }).map((_, i) => (
            <line
              key={`grid-h-${i}`}
              x1={padding.left}
              y1={padding.top + (i * chartHeight) / 4}
              x2={width - padding.right}
              y2={padding.top + (i * chartHeight) / 4}
              stroke="#1e293b"
              strokeWidth="1"
            />
          ))}

          <line
            x1={padding.left}
            y1={padding.top}
            x2={padding.left}
            y2={height - padding.bottom}
            stroke="#64748b"
            strokeWidth="2"
          />
          <line
            x1={padding.left}
            y1={height - padding.bottom}
            x2={width - padding.right}
            y2={height - padding.bottom}
            stroke="#64748b"
            strokeWidth="2"
          />

          {Array.from({ length: 5 }).map((_, i) => {
            const value = maxAmp - (i * ampRange) / 4;
            return (
              <text
                key={`label-y-${i}`}
                x={padding.left - 10}
                y={padding.top + (i * chartHeight) / 4 + 5}
                textAnchor="end"
                fill="#94a3b8"
                fontSize="12"
              >
                {value.toFixed(1)}
              </text>
            );
          })}

          <polyline
            points={points}
            fill="none"
            stroke="#0ea5e9"
            strokeWidth="2"
          />

          <text
            x={padding.left + chartWidth / 2}
            y={height - 5}
            textAnchor="middle"
            fill="#94a3b8"
            fontSize="14"
          >
            Time
          </text>
          <text
            x={15}
            y={padding.top + chartHeight / 2}
            textAnchor="middle"
            fill="#94a3b8"
            fontSize="14"
            transform={`rotate(-90, 15, ${padding.top + chartHeight / 2})`}
          >
            Amplitude (dB)
          </text>
        </svg>
      </div>
    );
  };

  const renderFrequencyBars = () => {
    if (frequencyBins.length === 0) {
      return (
        <div className="empty-state">
          <p>No frequency data available</p>
        </div>
      );
    }

    return (
      <div className="visualization-container">
        <div className="frequency-bars">
          {frequencyBins.map((bin, idx) => (
            <div key={idx} className="frequency-bar-item">
              <div className="bar-label">{(bin.frequency / 1000).toFixed(0)}k</div>
              <div className="bar-container">
                <div
                  className="bar-fill"
                  style={{
                    height: `${Math.min(100, Math.max(0, ((bin.amplitude + 30) / 30) * 100))}%`,
                    backgroundColor: '#0ea5e9'
                  }}
                ></div>
              </div>
              <div className="bar-value">{bin.amplitude.toFixed(1)} dB</div>
              <div className="bar-count">{bin.count} samples</div>
            </div>
          ))}
        </div>
      </div>
    );
  };

  const renderSpectrogram = () => {
    return (
      <div className="visualization-container">
        <div className="spectrogram-placeholder">
          <div className="placeholder-content">
            <div style={{ fontSize: '48px', marginBottom: '1rem' }}>SPEC</div>
            <p>Spectrogram View</p>
            <small>Coming soon: Real-time frequency analysis over time</small>
            <small style={{ marginTop: '0.5rem', display: 'block' }}>
              {signals.length} signals available for visualization
            </small>
          </div>
        </div>
      </div>
    );
  };

  const renderVisualization = () => {
    switch (visualizationType) {
      case 'spectrogram':
        return renderSpectrogram();
      case 'timeseries':
        return renderTimeSeries();
      case 'frequency':
        return renderFrequencyBars();
      default:
        return null;
    }
  };

  const calculateStats = () => {
    if (signals.length === 0) {
      return {
        peakAmplitude: 0,
        avgAmplitude: 0,
        minFreq: 0,
        maxFreq: 0,
        avgSNR: 0,
        avgQuality: 0,
      };
    }

    const amplitudes = signals.map(s => s.amplitude);
    const frequencies = signals.map(s => s.frequency);
    const snrs = signals.map(s => s.snr);
    const qualities = signals.map(s => s.quality);

    return {
      peakAmplitude: Math.max(...amplitudes),
      avgAmplitude: amplitudes.reduce((a, b) => a + b, 0) / amplitudes.length,
      minFreq: Math.min(...frequencies),
      maxFreq: Math.max(...frequencies),
      avgSNR: snrs.reduce((a, b) => a + b, 0) / snrs.length,
      avgQuality: qualities.reduce((a, b) => a + b, 0) / qualities.length,
    };
  };

  const handleExport = () => {
    if (signals.length === 0) {
      alert('No data to export');
      return;
    }

    const csv = [
      'Timestamp,Frequency (Hz),Amplitude (dB),Phase,SNR (dB),Quality (%)',
      ...signals.map(s =>
        `${s.timestamp},${s.frequency},${s.amplitude},${s.phase},${s.snr},${s.quality}`
      )
    ].join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `vlf-data-${stationId}-${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  };

  if (isLoading) {
    return (
      <div className="page-container">
        <div className="loading-state">
          <div className="spinner"></div>
          <p>Loading visualization...</p>
        </div>
      </div>
    );
  }

  const stats = calculateStats();

  return (
    <div className="page-container">
      <div className="page-header">
        <h1>Data Visualization</h1>
        <p>Advanced signal analysis for Observatory #{stationId}</p>
      </div>

      {error && <div className="alert alert-error">{error}</div>}

      <div className="visualization-controls">
        <div className="control-group">
          <label>Visualization Type:</label>
          <div className="button-group">
            <button
              className={`btn-control ${visualizationType === 'timeseries' ? 'active' : ''}`}
              onClick={() => setVisualizationType('timeseries')}
            >
              Time Series
            </button>
            <button
              className={`btn-control ${visualizationType === 'frequency' ? 'active' : ''}`}
              onClick={() => setVisualizationType('frequency')}
            >
              Frequency
            </button>
            <button
              className={`btn-control ${visualizationType === 'spectrogram' ? 'active' : ''}`}
              onClick={() => setVisualizationType('spectrogram')}
            >
              Spectrogram
            </button>
          </div>
        </div>

        <div className="control-group">
          <label>Time Range:</label>
          <div className="button-group">
            {(['1h', '6h', '24h', '7d'] as const).map(range => (
              <button
                key={range}
                className={`btn-control ${timeRange === range ? 'active' : ''}`}
                onClick={() => setTimeRange(range)}
              >
                {range.toUpperCase()}
              </button>
            ))}
          </div>
        </div>

        <button className="btn-primary" onClick={handleExport} disabled={signals.length === 0}>
          Export CSV
        </button>
      </div>

      <div className="section-card">
        {renderVisualization()}
      </div>

      {signals.length > 0 && (
        <div className="stats-grid">
          <div className="stat-card">
            <div className="stat-label">Data Points</div>
            <div className="stat-value">{signals.length.toLocaleString()}</div>
          </div>
          <div className="stat-card">
            <div className="stat-label">Peak Amplitude</div>
            <div className="stat-value">{stats.peakAmplitude.toFixed(2)} dB</div>
          </div>
          <div className="stat-card">
            <div className="stat-label">Average Amplitude</div>
            <div className="stat-value">{stats.avgAmplitude.toFixed(2)} dB</div>
          </div>
          <div className="stat-card">
            <div className="stat-label">Frequency Range</div>
            <div className="stat-value">
              {(stats.minFreq / 1000).toFixed(1)} - {(stats.maxFreq / 1000).toFixed(1)} kHz
            </div>
          </div>
          <div className="stat-card">
            <div className="stat-label">Avg SNR</div>
            <div className="stat-value">{stats.avgSNR.toFixed(1)} dB</div>
          </div>
          <div className="stat-card">
            <div className="stat-label">Avg Quality</div>
            <div className="stat-value">{stats.avgQuality.toFixed(1)}%</div>
          </div>
        </div>
      )}
    </div>
  );
};

export default DataVisualization;